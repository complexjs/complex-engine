{"name":"Complexjs","tagline":"JS Component Entity System","body":"<h1>ComplexJS</h1>\r\nComplexJS is a JS written Component Entity System for HTML5 Gamedevelopment.\r\nComplexJS has the ability not to slow your development time down.\r\nWith it's Component Entity System there is a high rate of reusable code for your later projects.\r\n<h2>Build</h2>\r\nYou can build ComplexJS by your own. There is a dev.js script where all the files are defined which will be compiled to gether into build/complex.js\r\nTherefore you need to install `littlehelper` via npm \r\n<pre>\r\n$ npm install littlehelper\r\n</pre>\r\n\r\n\r\n<h1>Getting started</h1>\r\nCreatea HTMLFile containing your view.\r\nAdd ComplexJS as a source\r\n`<script type=\"text/javascript\" src=\"./libs/complex.js\"></script>`\r\n    \r\n<h2>World</h2>\r\nThe world is the mainobject holding all the entities and systems.\r\nIf you want to make your game work you have to write an update loop and call `world.update` every tick\r\nTherefore I created a small lib called <a href=\"https://github.com/faebeee/Animloop\">Animloop.js</a>\r\n\r\n<h3>Create the world</h3>\r\n\r\n<pre>\r\nvar world = new cx.World();\r\n</pre>\r\n\r\n<h3>Update the world</h3>\r\nOverride the updatefunction of the animloop object. After calling `animloop.init()` the function `animloop.update()` is called every tick\r\n<pre>\r\nanimloop.update = function(){\r\n    world.update();\r\n}\r\nanimloop.init();\r\n</pre>\r\n\r\n<h2>Systems</h2>\r\nThe system is handling the datahandling of all components. For example moving around a object or rendering all entities to the canvas.\r\nThere where 2 different systemtypes `cx.EntitySystem` and `cx.VoidSystem`\r\n\r\n<h4>cx.EntitySystem</h4>\r\nThe EntitySystem is a system which reacts on entites which owns the same components as configured in the system\r\n\r\n<pre>\r\nvar MySystem = cx.EntitySystem.extend({\r\n    tag : \"MySystem\", // used to identify the system and retrive it back from the world\r\n    components : [\"PositionComponent\", \"SizeComponents\"], // the value of the tag property in your components\r\n\r\n    //constructor\r\n    init : function(){\r\n\r\n    },\r\n     /**\r\n     * called for an entity if the required components are matching these of the entity\r\n     * @param entity\r\n     * @param componens Key Value store. Components can be accessed with the componentName `components[\"myComponent\"]`\r\n     */\r\n    update : function( entity, componens){\r\n        //do what ever you want with your entity and its components\r\n    }\r\n});\r\n</pre>\r\n\r\n<h4>cx.VoidSystem</h4>\r\nVoidSystem is a system which does not react on each entity but is called everytime `world.update` is called. With this system you can easily implement other libraries like PIXI.js where you only have to call `update()` once every tick\r\n\r\n<pre>\r\nvar PixiSystem = cx.VoidSystem.extend({\r\n    tag : 'PixiSystem',\r\n\r\n    init : function(){\r\n        this.stage = new PIXI.Stage(0x66FF99);\r\n        this.renderer = PIXI.autoDetectRenderer(400, 300);\r\n        this.type = this.TYPE_VOID;\r\n\r\n        document.body.appendChild(this.renderer.view);\r\n    },\r\n\r\n    //called when an entity is added to world\r\n    added : function ( entity ){\r\n        var spriteComponent = null\r\n        if ( (spriteComponent = entity.getComponent('sprite')) != null ){\r\n            this.stage.addChild(spriteComponent.sprite);\r\n        }\r\n    },\r\n\r\n    update: function () {\r\n        this.renderer.render(this.stage);\r\n    }\r\n});\r\n</pre>\r\n\r\n<h3>Use a system</h3>\r\nTo make a system working you have to add it to the `cx.World`\r\n<pre>\r\nworld.addSystem(new MySystem());\r\n</pre>\r\n\r\n<h3>Get a system</h3>\r\nTo retrive a system you can call `getSystem(name)` where you have access to the world object.\r\nThe parameter `name` is the tag property of each system and should be unique\r\n\r\n<pre>\r\nworld.getSystem(\"PixiSystem\")\r\n</pre>\r\n\r\n<h2>Entities</h2>\r\nAn entity is just a holder for several components. \r\n\r\n<h3>Create entity</h3>\r\n<pre>\r\nvar hero = new cx.Entity();\r\n</pre>\r\n\r\n<h3>Add entity</h3>\r\nTo process and access all the components added to an entity you have to add it to the `cx.World` object. So every tick the systems can handle and modify the components data\r\n<pre>\r\nworld.addEntity(hero);\r\n</pre>\r\n\r\n<h2>Components</h2>\r\nA Component is a object which holds data for a specific entity. This data is processed by a system\r\n\r\n<h3>Create a Component</h3>\r\nA Component have to extend the `cx.Component` class\r\n<pre>\r\nvar ScriptComponent = cx.Component.extend({\r\n\tname:'cx.scriptcomponent', // defines a unique name to access this component later\r\n    \r\n    //properties\r\n\tscript : null,\r\n\tsetup : false,\r\n    \r\n    //constructor\r\n\tinit : function(script){\r\n\t\tthis.script = script;\r\n\t}\r\n});\r\n</pre>\r\n\r\n<h3>Add a component</h3>\r\nTo process the data in an component for a specific entity we have to add the component to that entity\r\n<pre>\r\nvar hero = new cx.Entity();\r\nhero.addComponent(new ScriptComponent());\r\n</pre>\r\nFrom now on you can access the `ScriptComponent` on the heroEntity\r\n\r\n<h3>Get a component</h3>\r\nTo access the component and its data you can access it via its unique name\r\n<pre>\r\nvar scriptComponent = hero.getComponent(\"cx.scriptcomponent\");\r\n</pre>\r\n\r\n<h2>Manager</h2>\r\nComing soon...\r\n\r\n<h2>Scripting</h2>\r\nComing soon...\r\n\r\n<h2>Demos</h2>\r\nComing soon...\r\n\r\n<h2>Contribution</h2>\r\nJust contribute. It's OpenSource\r\n\r\n<h2>Contact</h2>\r\n<a href=\"https://twitter.com/faebeee\">@Twitter</a><br>\r\n<a href=\"https://plus.google.com/u/0/113673733496424994581/posts\">+Google</a>","google":"UA-45541044-7","note":"Don't delete this file! It's used internally to help with page regeneration."}